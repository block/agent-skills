name: Validate Skills

on:
  pull_request:
    paths:
      - "**"
  pull_request_target:
    types: [opened, synchronize, reopened]
    paths:
      - "**"
  push:
    branches: [main]

permissions:
  contents: read
  pull-requests: write

jobs:
  validate:
    # Avoid double-running:
    # - pull_request runs only for same-repo PRs
    # - pull_request_target runs only for fork PRs
    # - push always runs
    if: |
      (github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name == github.repository) ||
      (github.event_name == 'pull_request_target' && github.event.pull_request.head.repo.full_name != github.repository) ||
      (github.event_name == 'push')
    runs-on: ubuntu-latest

    steps:
      # ✅ Trusted checkout (base repo)
      - name: Checkout base repo (trusted)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # ✅ Untrusted checkout (PR head) into ./pr (ONLY for reading files)
      - name: Checkout PR head into ./pr (untrusted)
        if: github.event_name == 'pull_request_target'
        uses: actions/checkout@v4
        with:
          ref: refs/pull/${{ github.event.pull_request.number }}/head
          path: pr
          fetch-depth: 0

      - name: Use Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Determine changed skill directories
        id: changed
        shell: bash
        run: |
          set -euo pipefail

          IGNORE_DIRS_REGEX='^(\.git|\.github|scripts|node_modules)(/|$)'

          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            BASE="${{ github.event.pull_request.base.sha }}"
            HEAD="${{ github.event.pull_request.head.sha }}"
            CHANGED_FILES="$(git diff --name-only --diff-filter=AM "$BASE..$HEAD" || true)"

          elif [[ "${{ github.event_name }}" == "pull_request_target" ]]; then
            # diff inside the fork checkout (./pr) so BASE..HEAD exist there
            BASE="${{ github.event.pull_request.base.sha }}"
            HEAD="${{ github.event.pull_request.head.sha }}"
            CHANGED_FILES="$(git -C pr diff --name-only --diff-filter=AM "$BASE..$HEAD" || true)"

          else
            BEFORE="${{ github.event.before }}"
            AFTER="${{ github.event.after }}"
            CHANGED_FILES="$(git diff --name-only --diff-filter=AM "$BEFORE..$AFTER" || true)"
          fi

          SKILL_DIRS="$(echo "$CHANGED_FILES" \
            | awk -F/ 'NF>1 {print $1}' \
            | grep -Ev "$IGNORE_DIRS_REGEX" \
            | sort -u \
            | tr '\n' ',' \
            | sed 's/,$//' \
            || true
          )"

          echo "changed_skills=$SKILL_DIRS" >> "$GITHUB_OUTPUT"

          if [[ -z "$SKILL_DIRS" ]]; then
            echo "No changed skill directories detected."
          else
            echo "Changed skill dirs: $SKILL_DIRS"
          fi

      # Always ensure a report file exists so downstream steps are stable.
      - name: Initialize validation report file
        shell: bash
        env:
          SKILLS_VALIDATION_REPORT: ${{ runner.temp }}/skills-validation-report.json
        run: |
          set -euo pipefail
          cat > "$SKILLS_VALIDATION_REPORT" <<'JSON'
          {
            "scanned_skills": [],
            "summary": { "fail_count": 0, "warn_count": 0, "status": "PASSED" },
            "findings": [],
            "timestamp": ""
          }
          JSON

      - name: Initialize validation output file
        shell: bash
        run: |
          set -euo pipefail
          : > "${{ runner.temp }}/skills-validation-output.txt"

      - name: Validate changed skills only (same-repo PRs + push)
        id: validate
        if: steps.changed.outputs.changed_skills != '' && github.event_name != 'pull_request_target'
        env:
          SKILLS_VALIDATION_REPORT: ${{ runner.temp }}/skills-validation-report.json
        run: |
          node scripts/validate-skills.mjs \
            --skills "${{ steps.changed.outputs.changed_skills }}" \
            --report "${SKILLS_VALIDATION_REPORT}" \
            2>&1 | tee "${{ runner.temp }}/skills-validation-output.txt"

      - name: Validate changed skills only (fork PRs via ./pr)
        id: validate_fork
        if: steps.changed.outputs.changed_skills != '' && github.event_name == 'pull_request_target'
        env:
          SKILLS_VALIDATION_REPORT: ${{ runner.temp }}/skills-validation-report.json
        run: |
          node scripts/validate-skills.mjs \
            --skills "${{ steps.changed.outputs.changed_skills }}" \
            --report "${SKILLS_VALIDATION_REPORT}" \
            2>&1 | tee "${{ runner.temp }}/skills-validation-output.txt"
        working-directory: pr

      - name: Upload validation report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: skills-validation-report
          path: |
            ${{ runner.temp }}/skills-validation-report.json
            ${{ runner.temp }}/skills-validation-output.txt
          if-no-files-found: error
          retention-days: 10

      - name: Comment validation results on PR (sticky)
        if: always() && (github.event_name == 'pull_request' || github.event_name == 'pull_request_target')
        uses: actions/github-script@v7
        env:
          REPORT_PATH: ${{ runner.temp }}/skills-validation-report.json
          OUTPUT_PATH: ${{ runner.temp }}/skills-validation-output.txt
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require("fs");

            const marker = "<!-- skills-validate -->";
            const reportPath = process.env.REPORT_PATH;
            const outputPath = process.env.OUTPUT_PATH;

            const issue_number = context.payload.pull_request?.number;
            if (!issue_number) {
              core.info("No pull_request found in payload; skipping PR comment.");
              return;
            }

            let report = null;
            if (fs.existsSync(reportPath)) {
              report = JSON.parse(fs.readFileSync(reportPath, "utf8"));
            } else {
              core.warning(`Validation report not found at ${reportPath}`);
            }

            const status = report?.summary?.status ?? "UNKNOWN";
            const fail = report?.summary?.fail_count ?? 0;
            const warn = report?.summary?.warn_count ?? 0;
            const scanned = Array.isArray(report?.scanned_skills) ? report.scanned_skills : [];
            const scannedText = scanned.length ? scanned.join(", ") : "(none)";

            let tail = "";
            if (fs.existsSync(outputPath)) {
              const lines = fs.readFileSync(outputPath, "utf8").split(/\r?\n/);
              tail = lines.slice(-200).join("\n").trim();
            }

            const titleStatus =
              status === "PASSED" ? "✅ PASSED" :
              status === "FAILED" ? "❌ FAILED" :
              status === "WARN"   ? "⚠️ WARN" :
              `ℹ️ ${status}`;

            let body = [
              marker,
              `## ✅ Validate Skills — **${titleStatus}**`,
              `**Summary:** FAIL=${fail} · WARN=${warn}`,
              `**Changed skill dirs:** ${scannedText}`,
              ""
            ].join("\n");

            if (tail) {
              body += [
                "### Output (last 200 lines)",
                "```",
                tail,
                "```",
                ""
              ].join("\n");
            } else {
              body += "_No validator output captured._\n";
            }

            const { owner, repo } = context.repo;

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner, repo, issue_number, per_page: 100
            });

            const existing = comments.find(c => (c.body || "").includes(marker));

            if (existing) {
              await github.rest.issues.updateComment({ owner, repo, comment_id: existing.id, body });
              core.info("Updated existing sticky validate comment.");
            } else {
              await github.rest.issues.createComment({ owner, repo, issue_number, body });
              core.info("Created new sticky validate comment.");
            }

      # Label ONLY when WARN/FAIL. Also remove it when clean.
      # Runs for pull_request_target (fork PRs) too, since it has write perms.
      - name: Update security-review-required label based on report
        if: always() && (github.event_name == 'pull_request' || github.event_name == 'pull_request_target')
        uses: actions/github-script@v7
        env:
          REPORT_PATH: ${{ runner.temp }}/skills-validation-report.json
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require("fs");
            const label = "security-review-required";
            const reportPath = process.env.REPORT_PATH;

            if (!fs.existsSync(reportPath)) {
              core.setFailed(`Expected report at ${reportPath} but it was not found.`);
              return;
            }

            const report = JSON.parse(fs.readFileSync(reportPath, "utf8"));
            const warn = report?.summary?.warn_count ?? 0;
            const fail = report?.summary?.fail_count ?? 0;

            const issue_number = context.payload.pull_request?.number;
            if (!issue_number) {
              core.info("No pull_request found in payload; skipping label update.");
              return;
            }

            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const shouldHaveLabel = (warn > 0 || fail > 0);

            const { data: existing } = await github.rest.issues.listLabelsOnIssue({
              owner, repo, issue_number, per_page: 100
            });
            const hasLabel = existing.some(l => l.name === label);

            if (shouldHaveLabel && !hasLabel) {
              core.info(`Applying "${label}" (warn=${warn}, fail=${fail})`);
              await github.rest.issues.addLabels({
                owner, repo, issue_number,
                labels: [label],
              });
            } else if (!shouldHaveLabel && hasLabel) {
              core.info(`Removing "${label}" (warn=${warn}, fail=${fail})`);
              await github.rest.issues.removeLabel({
                owner, repo, issue_number,
                name: label,
              });
            } else {
              core.info(`No label change needed. hasLabel=${hasLabel} warn=${warn} fail=${fail}`);
            }
